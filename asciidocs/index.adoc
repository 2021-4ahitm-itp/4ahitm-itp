= Lecture Notes 4ahitm ITP 20/21
firstname lastname
1.1.0, yyyy-mm-dd: Some notes
ifndef::imagesdir[:imagesdir: images]
//:toc-placement!:  // prevents the generation of the doc at this position, so it can be printed afterwards
:sourcedir: ../src/main/java
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc: left

//Need this blank line after ifdef, don't know why...
ifdef::backend-html5[]

// https://fontawesome.com/v4.7.0/icons/
//icon:file-text-o[link=https://raw.githubusercontent.com/htl-leonding-college/asciidoctor-docker-template/master/asciidocs/{docname}.adoc] ‏ ‏ ‎
//icon:github-square[link=https://github.com/htl-leonding-college/asciidoctor-docker-template] ‏ ‏ ‎
//icon:home[link=https://htl-leonding.github.io/]
endif::backend-html5[]

// print the toc here (not at the default position)
//toc::[]


<<students.adoc#, students notes>>

== Fragen

* Warum bezeichnet man Scrum und ähnliche Vorgehensmodelle als agil?
+
.Antwort
[%collapsible]
====
* Durch die kleinteilige Erstellung des Softwaresystems, kann man auf geänderte Rahmenbedingungen im Projektverlauf reagieren.
* Die Funktionalität von Individualsoftware kann früh(er) beurteilt werden. zB besonders wichtig bei Erweiterung von bestehenden (komplizierten) Systemen
====

* Unterschied FA - NFA + Beispiele

== What to do

* [x] Projektthema bestimmen
* [ ] Pflichtenheft erstellen

== 2020-09-24

=== Anforderungen an Projekte / Curriculum

https://htl-leonding-college.github.io/syp-itp-lecture-notes/sypitp4.html

=== Architektur von db-basierten Projekten

image:architecture-projects.jpg[]

=== Projekte

[%collapsible]
====
* Europäische Urwaldroute
** Adrian
** Silvio
** Jakob m/4
* Leonie
** Jonas littleCity
** Basti Langhaar
** Jonas Nr 3
** Nina
** der Bär
* Rocketman -> Prof. B. Ernecker
** Sarah mit Haube
** Synchronsprecher
* link:resources/duennschichtchromatogramm.pdf[Dünnschichtchromatogramm, window="_blank"] -> Prof. B. Ernecker
** n/a
* School-IoT "The appealing classroom"
** Jonas Känga
** Phil
** Quirinus
* LeoSchool -> derzeit Diplomarbeit
** LeoDatabaseLearner
*** Primerl
*** Isabel
*** Marah
** LeoSurvey
** LeoCode
* LeoTurnier
** Rosi
** Kelly
** Sandy
* DigitalSignage - On-Demand Videos
** Meris
** Airy Jakob
** Blondie123
* DigitalSignage - AlertMessenger
** 11 Simon Langhaar
** Florian aus St. Florian
* openMower-Projekt
====

[[project-details]]
.Project School-Iot Details
[%collapsible]
====

* Analyse des Istzustandes
* Erstellung des Gesamtkonzepts
* Detaillierung des Projektumfangs
* ...
====


.Project DigitalSignage Details
[%collapsible]
====

[plantuml,digsignage,png]
----
@startuml
node ds_cms
node server
node keycloak
node angular_client
ds_cms -right0)- server : rest
server -right0)- angular_client : rest
@enduml
----

* ds_cms: Digital Signage Server mit Restful Endpoint
* server: quarkus (ev. nodejs) bereitet die REST-Endpoints für den Angular Client vor
* angular_client:
** *On-Demand Video*: Berechtigte Personen können aus einer Video-Library auf beliebigen Screens
Videos abspielen. Das momentane Programm wird überblendet.
** *AlertMessenger* Berechtigte Personen (Sekretariat, AV, Dir, Schulwart) können (wichtige) Nachrichten
auf beliebigen Screens für eine beliebige Zeitdauer (jjjj-mm-dd hh:mm VON - BIS). Die Nachricht kann in
einem online HTML-Editor formatiert werden. Automatisch wird darunter klein angegeben, wer die Nachricht geschalten hat.

====

=== Unterricht

* Foliensatz 01_Vorgehensmodelle begonnen (bis V-Modell)

=== Projekte

==== Project Proposal (Projektantrag)

== 2020-10-09

=== Git Grundlagen






== Feedback Projektauftrag

=== Digital Signage

* Beim Projekt ist das `out`-Verzeichnis im Repo eingecheckt
** `out` ist das Gegenstück zu `target` nur für Ant -> maven ist obligatorisch!
** `out` wurde generiert und darf NICHT in ein Repo eingcheckt werden !!!


==== ad Problemstellung

****
Es wird im Zuge eines ITP - Projekts eine Oberfläche für einen Touchscreen
erstellt, bei dem es aber keine Möglichkeit gibt den Inhalt auf einem Smartphone
zu verwalten.
****

** Habt Ihr jetzt ein anderes Projekt?
** Diese Problemstellung kenne ich nicht
** Welcher Touchscreen?

IMPORTANT: Bei der Problemstellung darf die Lösung nicht enthalten sein.

==== ad Aufgabenstellung

****
In Kooperation mit dem anderen DigitalSignage Team wird das Backend
für unsere Anwendungen programmiert.
Unser Team erstellt zusätzlich noch eine Swift - Applikation von der aus
die ganze Oberfläche des Touchscreens verwaltet werden kann.
****

* Bis jetzt, weiß man noch nicht was das Problem ist,
* was eigentlich erstellt werden soll,
* aber es wird auf ein ominöses zweites Team verwiesen (das es wahrscheinlich gar nicht mehr gibt)
* Es wird ein Swift Anwendung zusätzlich zu was programmiert?

==== ad Funktionalität

****
Ein Benutzer kann sich auf der Applikation einloggen.

Berechtigte Benutzer können dann von der App aus den Inhalt der Oberfläche
"ferngesteuert" verwalten. (Videos abspielen, pausieren, etc.)
****

* Einloggen ist kein Use-Case
* Der zweite Use-Case ist ok


==== Restliche Kapitel

* Sind leer
* Besonders das Projektergebnis wäre wichtig (wurde bereits in der Problemstellung erstellt)
* Eure Projektphasen sind ebenfalls hochinteressant
** Aufbau eines lokalen Xibo-Servers
** Lernen der Grundfunktionen von Xibo
** Marktanalyse
*** Welche Möglichkeiten zur Authentifizierung gibt es?
** Analyse der Xibo-Rest-Schnittstelle
*** Erster Zugriff auf Xibo mittels Insomnia oder Postman
*** Erstellen eines ersten einfachen Quarkus-Prototypen
** ...

IMPORTANT: Leider wird im Repo (rechts oben) oder im README.md nicht der URL der gh-pages angegeben

https://2021-4ahitm-itp.github.io/01-project-proposal-digitalsignage-application/

IMPORTANT: Eure Klarnamen müssen / sollten nicht im Internet publiziert werden


[WARNING]
.Folgende Fragen müssen beantwortet werden:
====
* Wieso hat nur ein Teamitglied committed?
* Ist das Projektteam überfordert (-> Ja)
* Sollte das Projektteam nicht besser ein einfacheres Thema nehmen?
* Sollte man das Projektteam nicht auf andere Teams aufteilen?
====


==== Beurteilung

* Obwohl in diesem Dokument weiter oben (<<project-details>>) das Projekt bereits besprochen wurde, ist dies das Ergebnis

-> ngd (5)







=== European Primeval Forest Route

==== Allgemeine Anmerkungen

* keine generierten Verzeichnisse comitten
** `.asciidoctor` wurde eingecheckt
** nicht einfach "alles" comitten !!!

* Es gibt zwei Branches für die gh-pages
** doc
** gh-pages
** In den https://2021-4ahitm-itp.github.io/01-project-proposal-european-primeval-forest-route/[gh-pages] wird nichts angezeigt

* Man muss im Projekt das File mit dem Projektauftrag erst suchen
** das ist auch der Grund, warum man in den gh-pages "nichts" findet (das Unter-Unterverzeichnis wird nicht gerendert)
** Das ganze Projekt ist "Kraut und Rüben"

image:forest-directory-structure.png[]

* Rechtschreibfehler

==== ad Problemstellung

****
In der Vergangenheit kam es öfters vor, dass durch motivierte Wanderer die Vegetation verschmutzt und zerstört wurde,
indem sie unmakierte/unoffizielle Wege nahmen.
Um die Tiere und Organismen in solchen Gebieten in Zukunft zu schützen wird eine Software entwickelt.
****

IMPORTANT: In der Problemstellung hat die Lösung nichts verloren.

==== ad Was kann das Softwareprodukt nicht?

****
.Was soll das bedeuten?
image:forest-01.png[]
****

==== ad Projektphasen


****
.zuwenige Phasen angeführt - das gesamte Projekt sollte geplant werden
image:forest-02.png[]
****

==== Projektstart und Projektende

* Die könnte man schätzen

==== Projektresourcen

****
image:forest-03.png[]
****

* Warum will jedes Projekt einen Swift Client erstellen?


==== Beurteilung

* Man kann sich gut vorstellen, was zu tun ist
* es fehlen ganze Kapitel (Ziele, ...)
* Das Projekt ist in einem nicht-verwendbaren Zustand
* -> gen(4)






=== OnDemand

==== Allgemeines

* Der Link zu den gh-pages in README.md vorhanden
* Warum hat nur eine Person committed?
* Warum gibt es einen Ordner "Organise"

==== ad PRoblemstellung

* Vermischung mit Ausgangssituation

==== ad Aufgabenstellung

****
.sehr abstrakt - könnte und sollte konkreter sein
image:demand-01.png[]
****

==== ad Projektphasen

* tw. ok, jedoch ungenügende Präzisierung (Welches System ist kennzulernen)
* sehr optimistisch
* vergleiche die Kommentare des anderen Projekts

==== ad Projetstart und Projektende

****
.Da sollten wohl Kalenderdaten stehen
image:demand-02.png[]
****


==== Beurteilung

* Man kann sich vorstellen, was das Ergebnis ist
* sogar messbare Eigenschaften
* Man hat das Gefühl die beteiligten PErsonen haben sich was überlegt

-> bef(3)





=== Rocketman

n/a





=== School-IoT

==== Allgemeines

* Links zu gh-pages in README.md vorhanden
* keine Klarnamen im Internet

==== ad Background

* naja

==== Beurteilung

* Man kann sich überhaupt nicht vorstellen, ...
** ... um was es geht?
** ... was bereits vorhanden ist (Sonsorbox und Vorgängerprojekt)
** ... Das damit die Qualität in den Klassen (Luftqualität) verbessert werden soll;
die Schüler werden leistungsfähiger
* Das Architekturdiagramm ist toll
** jedoch nicht mit Plantuml erstellt
** und trotzdem schaffen es die die Pfeile nicht korrekt wo hinzuzeigen
* Obwohl in diesem Dokument weiter oben (<<project-details>>) das Projekt bereits besprochen wurde, ist dies das Ergebnis

-> ndg(5)





=== Tournament

==== Allgemeines

image:tournament-01.png[]

* Warum ist im git-repo wieder ein Unterverzeichnis
* das repo hat kein README.md
* das generierte Verzeichnis `.asciidoctor` ist ins repo eingecheckt
* Euer Projektauftrag hat den Titel "My Project" und ist ein Mischmasch mit meinem Pflichtenheft-Template
* Den Projektauftrag habt ihr Projektantrag genannt
* Rechtschreibfehler
* keine Klarnamen im Web

==== Inhaltlich

* Projektphasen entsprechen dem Projekt der dritten Klasse
* eigentlich ziemlich ok, ist aber nicht überraschend, da es das Gleiche vom Vorjahr ist

-> gen(4)

=== Konsequenzen

* Ein neues Repo für das Pflichtenheft ist von allen Teams zu erstellen


== 2020-11-13

=== Semantic Versioning

* https://semver.org/lang/de/

* Versions-Nr zB 1.2.5
* Struktur: MAJOR.MINOR.PATCH
** MAJOR: Neue Version, die nicht kompatibel mit den Vorgängerversionen ist +
Die API "bricht", neue Features
** MINOR: Neue Version mit neuen Features, die kompatibel mit Vorgängerversionen ist
** PATCH: Neue Version, *KEINE* neuen Features, nur Bug-Fixes (Fehlerbehebungen)
* Erweiterungen zB mit Build Nr: zB 1.2.5.1212423

=== DOM -- Domain Object Modell

* D ... Fachbereich
* O ... Object
* M ... Model

-> Fachbereichsobjektmodell

* Beispiele:
** Hausarzt -> Patient, Diagnose, Fall, ...
** Handel -> Produkt, Kunde, Rechnung, Mahnung, Lieferung
** ...

* *Keine* technischen Klassen
* vergleichbar mit einem ERD (Entity-Relationship-Diagram)
* wird zB in einer SysSpec (Pflichtenheft) verwendet
* Man kann mit dem Kunden über seine Geschäftsobjekte sprechen.

=== Mögliche Vorgehensweise

image:how-to-begin.png[]


== 2020-11-20

=== Frage

[source,java]
----
class VehicleTest {

    @Test
    void createVehicle() {
        Vehicle commodore = new Vehicle("Opel", "Commodore", 100.0);
        assertThat(commodore.getBrand()).isEqualTo("Opel");
    }
}
----

* Frage:
** Ist bei diesem Test ein @QuarkusTest notwendig?
** Begründen Sie Ihre Antwort

* Antwort:
** Es ist ein einfacher Unit-Test einer Klasse.
** Dabei sind keine Abhängigkeiten notwendig.
** Man injiziert nicht (es gibt kein @Inject)


== 2020-12-04

=== Arten von Zielen

image:leistungsziele.png[]

* Zielarten
** Wirkungssziele
** Ergebnisziele
** Prozessziele

https://www.wirkung-lernen.de/wirkung-planen/ziele/erarbeiten/

image:vmodell.png[]


=== Behaviour Driven Design - BDD (Karate & Gherkin)

https://de.wikipedia.org/wiki/Behavior_Driven_Development

---

.Arten der Softwareentwicklung
* *klassisches Vorgehen*
** Erstellen eines detaillierten Pflichtenheftes für das ganze Projekt
** Vorgehensmodelle: Wasserfallmodell / V-Modell
** Dokumente: Pflichtenheft (WAS), Entwurf (WIE), Projekthandbuch (ORGANISATION)
** Implementieren des gesamten Projekts
** Ausliefern des gesamten Projekts (Big Bang)
* *agile Vorgehen*
** das gesamte Projekt wird zunächst nur grob umrissen
** Vorgehensmodelle: Scrum, Kanban
** Scrum: Epics und Userstories
*** immer die nächsten User Stories werden detailliert mit Tasks beschrieben ...
*** ... und anschließend implementiert, getestet und an den Kunden ausgeliefert
*** Starke Mitarbeit des Kunden
*** Übersicht aller User Stories im Product Backlog
*** zeitliche Zielsetzungen mittels Sprints

---

* Qualität: sehr allgemein formuliert -> ist das, was der Kunde wünscht

---

* Konzept: BDD
** aus der sicht des Kunden werden die Tests erstellt
** die Tests werden sprachneutral (i.S.v. Programmiersprachen) als Gherkin-files erstellt (feature-Files)
** Karate ist das Testframework, welches die Tests ausführt
** Karate wird von jUnit Tests (also von Java) aufgerufen

=== Karate

image:karate-overview.png[]

.Karate-Statement
image:https://raw.githubusercontent.com/intuit/karate/master/karate-demo/src/test/resources/karate-hello-world.jpg[]

https://github.com/intuit/karate

.Erstellen des Projekts
----
mvn io.quarkus:quarkus-maven-plugin:1.9.2.Final:create \
    -DprojectGroupId=at.htl \
    -DprojectArtifactId=quarkus-karate-demo \
    -DclassName="at.htl.karate.boundary.GreetingResource" \
    -Dpath="/hello"
----

.pom.xml
[source,xml]
----
    <dependency>
      <groupId>com.intuit.karate</groupId>
      <artifactId>karate-apache</artifactId>
      <version>0.9.6</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>com.intuit.karate</groupId>
      <artifactId>karate-junit5</artifactId>
      <version>0.9.6</version>
      <scope>test</scope>
    </dependency>
    ...

  <build>
    <testResources>
      <testResource>
        <directory>src/test/java</directory>
        <excludes>
          <exclude>**/*.java</exclude>
        </excludes>
      </testResource>
    </testResources>
    <plugins>
    ...
    </plugins>
  ...
  </build>
----

.src/test/java/karate-config.js
[source,javascript]
----
function fn() {
    var env = karate.env; // get java system property 'karate.env'
    karate.log('karate.env system property was:', env);
    if (!env) {
        env = 'dev'; // a custom 'intelligent' default
    }
    var config = { // base config JSON
        baseUrl: 'http://localhost:8081'
    };
    // don't waste time waiting for a connection or if servers don't respond within 5 seconds
    karate.configure('connectTimeout', 5000);
    karate.configure('readTimeout', 5000);
    return config;
}
----


=== Aufgabe Karate

* Erstelle einen Endpoint mit einem PathParameter
** localhost:8080/hello/susi ergibt einen Rückgabewert "hello susi"
** einmal als plain text, einmal als xml und einmal als json
* Erstellen einer Entität Vehicle mit brand und type
** Create eines Vehicles über Endpoint
** Das Vehicle ist ein File
** siehe dazu https://github.com/htl-leonding-college/quarkus-karate-testcontainers-demo



== 2021-01-15

* Projektarbeit
** Feedback für Leonie
** TNMS Helfenberg


== 2021-01-22

=== Erstellen von Unit-Tests

==== Was teste ich
* Unit-Tests sind NICHT (oder nur teilweise) das testen von Gettern und Settern.
** Es ist nicht sinnvoll, von der IDE generierte Getter und Setter zu testen.
* Zu testen ist:
** Das Zusammenspiel der Klassen (die Assoziationen, Vererbungs- und sonstigen Beziehungen)
** Eigene MEthoden, die zusätzlich zu Konstruktoren, Gettewrn und Settern erstellt wurden
** Collections und der Zugriff darauf

=== Wie gehe ich beim Testen vor

* Man geht von den Anwendungsfällen aus:

** Bsp: Umfragetool QuestionZ
*** US1: Der Befrager erstellt einen Fragebogen
*** US2: Der Befrager erstellt eine Umfrage
*** US3: Die Befragten nehmen an einer Umfrage teil
*** Us4: Der Befrager wertet die beantworteten Fragebögen aus

* Man erstellt für jeden Anwendungsfall eigene Tests (ein oder mehrere, zB Sonderfälle)
** ev. ohne Persistierung, die Datenbank aber sehr wohl verwendet.
** es geht um das Ergebnis
*** zB bei US1: Es steht ein Fragebogen zur Verfügung (zB mit 6 Fragen und allen Fragetypen), in der Datenbank (oder nur im Hauptspeicher als Java-Objekte)
*** zB bei US2: Eine fertig erstellte und konfigurierte Umfrage (Datum, TANS sind gerneriert, ...), in der Datenbank (oder nur im Hauptspeicher als Java-Objekte)
*** zB bei US3: zB fünf ausgefüllte Fragebögen in der Datenbank (oder nur im Hauptspeicher als Java-Objekte)
*** zB bei US$: Die Auswertung wird in unserem Beispiel nicht in der DB gespeichert. Als werden nur die Summen / Mittelwerte usw auf Korrektheit getestet

=== Ziel des Unit-Tests

* Fehler sollen frühzeitig erkannt werden - speziell im Datenmodell
** Das Datenmodell ist die Grundlage des gesamten Softwaresystems und Fehler darin ziehen umfangreiche Änderungen bis in die GUI nach sich.
** Die Abläufe werden in den Tests simuliert.
** Sind die Ergebnisse dieser getesteten Abläufe in Ordnung beginnt man mit der nächsten Schicht
** Test-Schichten
*** Entity-Tests (ev. noch ohne Persistierung)
*** Repository-Tests
*** Endpoint-Tests
*** GUI-Tests (meist der Webanwendung)


=== TODO - Kommentar

* In intellij una anderen IDEs gibt es ein eigenes Fenster, in dem alle TODOs aufgelistet werden.


=== Vorgehensweise

==== kleine Schritte

* Man versieht nicht alle Klassen mit Persistenzannotationen sondern ...
* \... man beginnt mit einer Klasse, die man sofort persistiert in einem Unit-Test

==== Repository Pattern verwenden

* siehe Microsoft
* aggregates verwenden, nicht jede Entity-Klasse hat ein eigenes Repository


==== keine unverschlüsselten Credentials (passwords usw) im github speichern

== 2021-03-04

* Erstellen eine Pipeline mit gh-actions
** Vergleichsprodukt zu gh-actions ist Jenkins, Travis, ...
** Erstellen von ssh-keys
** infrastructure-as-code
** Zweck: Nach dem Pushen der Files in das git-repo wird automatisch
*** kompiliert
*** getestet und
*** deployed (zB auf einen Server kopiert und gestartet)


== 2021-03-05

* Was soll der (begeisterte) ITP-Schüler und auch -in immer können:

** git (Theorie + Praxis)
*** Versionsnummern (Aufbau)

** github-actions (Theorie)
*** ssh-keys
*** Erstellen einer Pipeline

** Vorgehensweise beim Durchführen von Projekten (Theorie und Praxis)
*** Scrum vs klassische Vorgehensweise
*** Strukturierung eines Projekt in github
*** V-Modell

** Testen
*** Welche Arten von Tests
*** Welche Test-Frameworks werden wie angewendet (Theorie und Praxis)

** UML-Diagramme
*** CLD und Objektdiagramm
*** ACD
*** State Diagram
*** Deployment Diagram
*** Kompositionsstrukturdiagramm

----
wird nicht geprüft, muss vorher noch gemacht werden
** Virtualisierung mit Docker (Theorie)
*** docker-compose "Jeder Dienst ein eigener Container"
----

** Build-Tools
*** Zweck
*** Funktionalität
**** Einbinden und automatischer Download von Libraries
**** Einbinden von Plugins
*** Varianten: v.a. maven, gradle, npm, ...



=== Organisation von Projekten mit github und gh-projects

* Problem:
** Die bevorzugte Vorgehensweise ist *Scrum*
** In github gibt es allerdings "nur" *Kanban*
*** keine Sprints sondern Meilensteine
*** keine User Stories und Tasks, nur Issues die in gh-project (vglbar mit Sprint Backlog) dargestellt werden können
*** User Stories sind Issues mit einem Tag "User Story"

* Wie werden Issues sonst noch verwendet?
** Die Tasks werden in gh-Projects je nach Ihrem Zustand (open/in progress/to review/done) dargestellt
** Gesprächsprotokolle werden mit m-o-m (Minutes of Meeting) gekennzeichnet
** Bug-Reports werden mit "bug" gekennzeichnet und als Task in das gh-projekt eingetragen

* Ganz wichtig ist die konkrete Zuordnung von Aufgaben zu Teammitgliedern
** Ein Issue (Task, Bug, ...) soll nur einem Teammitglied zugeordnet sein (es kann Ausnahmen geben)
** Es soll jedem Task (und auch Bugfix, ...) eine Fertigstellungsdatum zugeordnet werden durch die Verwendung von Meilensteinen
** Die Aufgabe die im Task beschrieben ist, soll klar lösbar, kontrollierbar und testbar sein
*** der Projektkoordinator (Projektleiter) soll den Teammitgliedern entsprechend ihrer Fähigkeiten die Aufgaben zuordnen.
*** die Erfüllung dieser Aufgaben ist Teil der Bewertung
*** Gibt es Aufgaben, die nicht programmiert werden zB Marktanalyse, Entwurfsentscheidung, ... dann muss es ebenfalls ein Ergebnis geben zB einen (kurzen) Bericht darüber
*** Die einzelnen Commits sind durch `#<no des issues>` den Issues (Tasks, Bugfixes usw) zuzuordnen
*** Die User Stories können nummeriert werden zB "US-01 Eintragung einer Fahrt"
*** Somit können die Tasks den User Stories zugeordnet werden, zB "Repositories erstellen (US-01)"
*** Eine Alternative zu dieser Strukturierung:
**** Die Meilensteine erhalten dieselben Bezeichnungen wie die User-Stories
**** Jeder Task ist dem entsprechenden Meilenstein zugeordnet (so ersieht man ebenfalls die Zugehörigkeit zu einer User Story)
+
IMPORTANT: Jeder Meilenstein hat ein Datum

*** Grundsätzlich ist das System nach Beendigung eines Tasks lauffähig (IMMER)
*** Wenn ein Teammitglied eine neue Aufgabe zugewiesen bekommt zB eine neue Funktion, so ist ein Feature-Branch zu erstellen
**** dh der Main Branch ist *immer* lauffähig
**** nach Fertigstellung des neuen Features gibt es ein Code Review mit anschließendem Merge
**** oder es gibt einen Pull-Request mit anschließendem Review und ev. Merge


=== Beispiel: Wie kann man ein Projekt zerlegen

==== Überblick verschaffen

* Zb Erstellen eines UCDs

[plantuml,ucd-rudern,png]
----
@startuml
left to right direction
actor user
rectangle ruderxxx {
  user -- (Fahrt eintragen)
  user -- (Route eintragen)
  user -- (Auswertung)
}
@enduml
----

* Oft dient die Strukturierung mit Use-Case-Diagrammen als Anhaltspunkt für Meilensteine.
* Hier könnte man zB drei Meilensteine definieren
** Fahrt eintragen
** Route eintragen
** Auswertung
* zusätzliche Meilensteine könnten sein
** Vorbereiten der Infrastruktur (Server aufsetzen)
** Prototyps für Eintragen des Standorts per GPS

* Es sind alle Meilensteine zu erstellen und mit (geschätzten) Fertigstellungsterminen zu versehen.
** Der Detaillierungsgrad (ob die Tasks schon für den jeweiligen Meilenstein erstellt wurden) nimmt bei späteren Meilenstainen ab.
* Unterteilt man in Frontend und Backend als getrennte Systeme, so ist es sinnvoll die Schnittstelle zwischen diesen beiden System zu definieren.
* Anschließend kann man für jedes System die Funktionalität auflisten und abarbeiten

* Frage: was ist der Unterschied von Use-Case (Anwendungsfälle) zu User Stories
** Beide definieren Anforderungen / Funktionalitäten aus Kundensicht
** Use-Cases sind etwas größer (vllt. kann man sagen, dass ein UC aus mehreren User-Stories bestehen kann)
** User Stories sind etwas detaillierter, da aufgrund dieser programmiert werden muss (mit einem konkreten Ergebnis)


== 2021-03-XX

IMPORTANT: Vorstellen der Verschlüsselung von Stefnotch zum einpflegen von Secrets in github -> Jonas Dorfinger


== 2021-03-26 (Freitag)

* Es wurde festgestellt, dass noch Defizite im Bereich Docker und docker-compose bestehen
* -> nach den Osterferien wird Docker durchgearbeitet
* im Rahmen des Deployments per gh-actions auf eine Oracle VM

== 2021-04-30

=== Überblick Dockerfile-image-Container
image:docker-dockerfile-image-container.png[]

=== Bind Mount vs. Volume
image:docker-bindmount-vs-volume.png[]


=== Start eines nginx-Docker-Containers
image:docker-starten-nginx.png[]


=== Docker-Compose
image:docker-compose.png[]

















